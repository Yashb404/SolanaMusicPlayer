import { useState, useCallback, useEffect, useMemo } from 'react';
import { BN, Program, web3 } from '@coral-xyz/anchor';
import { PublicKey } from '@solana/web3.js';
import { useMusicPlayerProgram, createPlaylistPDA, createTrackPDA, createUserProfilePDA } from '@/lib/solana-program';

// Typed IDL generated by Anchor (already in your repo as src/music_player.ts)
import type { MusicPlayer } from '@/music_player';

// On-chain account shapes for local state
export interface OnChainTrack {
  id: BN;
  owner: PublicKey;
  title: string;
  artist: string;
  genre: string;
  uri: string;
  createdAt: BN; // i64 => BN on client
}

export interface OnChainPlaylist {
  id: BN;
  owner: PublicKey;
  name: string;
  description: string;
  tracks: BN[];  // Vec<u64> => BN[]
  createdAt: BN;
  updatedAt: BN;
}

export const useMusicPlayer = () => {
  // program/provider from your solana-program.ts
  const ctx = useMusicPlayerProgram();
  const program = useMemo(() => (ctx?.program as unknown as Program<MusicPlayer>) ?? null, [ctx]);
  const provider = ctx?.provider ?? null;

  const [isLoading, setIsLoading] = useState(false);
  const [tracks, setTracks] = useState<OnChainTrack[]>([]);
  const [playlists, setPlaylists] = useState<OnChainPlaylist[]>([]);

  // Fetch everything when program becomes available
  useEffect(() => {
    if (!program || !provider) return;
    fetchTracks();
    fetchPlaylists();
  }, [program, provider]);

  // Pull all track accounts from chain (uses IDL account name "track")
  const fetchTracks = useCallback(async () => {
    if (!program) return;
    try {
      const res = await program.account.track.all();
      setTracks(res.map(r => r.account as OnChainTrack));
    } catch (e) {
      console.error('fetchTracks error:', e);
    }
  }, [program]);

  // Pull all playlist accounts from chain (uses IDL account name "playlist")
  const fetchPlaylists = useCallback(async () => {
    if (!program) return;
    try {
      const res = await program.account.playlist.all();
      setPlaylists(res.map(r => r.account as OnChainPlaylist));
    } catch (e) {
      console.error('fetchPlaylists error:', e);
    }
  }, [program]);

  // Initialize user profile for the connected wallet
  const initializeUser = useCallback(async (username: string, email: string) => {
    if (!program || !provider) throw new Error('Program not initialized');

    setIsLoading(true);
    try {
      const [userProfilePDA] = createUserProfilePDA(provider.wallet.publicKey);

      // Newer Anchor resolves PDAs automatically; only pass signer
      await program.methods
        .initializeUser(username, email)
        .accounts({
          signer: provider.wallet.publicKey,
        })
        .rpc();

      return userProfilePDA;
    } finally {
      setIsLoading(false);
    }
  }, [program, provider]);

  // Upload a track: generate a unique u64 id (BN), let IDL seeds derive PDA
  const uploadTrack = useCallback(async (title: string, artist: string, genre: string, audioUri: string) => {
    if (!program || !provider) throw new Error('Program not initialized');

    setIsLoading(true);
    try {
      const trackId = new BN(Date.now()); // quick unique u64
      const [trackPDA] = createTrackPDA(provider.wallet.publicKey, trackId);

      await program.methods
        .uploadTrack(trackId, title, artist, genre, audioUri)
        .accounts({
          signer: provider.wallet.publicKey,
          // PDA "track" is inferable; do NOT pass unless you want strict control
          // track: trackPDA,
        })
        .rpc();

      // Optionally, refetch or optimistically update UI
      await fetchTracks();
      return { trackId, trackPDA };
    } finally {
      setIsLoading(false);
    }
  }, [program, provider, fetchTracks]);

  // Create a playlist with a generated u64 id (BN)
  const createPlaylist = useCallback(async (name: string, description: string) => {
    if (!program || !provider) throw new Error('Program not initialized');

    setIsLoading(true);
    try {
      const playlistId = new BN(Date.now());
      const [playlistPDA] = createPlaylistPDA(provider.wallet.publicKey, playlistId);

      await program.methods
        .createPlaylist(playlistId, name, description)
        .accounts({
          signer: provider.wallet.publicKey,
          // PDA "playlist" is inferable; do NOT pass unless you want strict control
          // playlist: playlistPDA,
        })
        .rpc();

      await fetchPlaylists();
      return { playlistId, playlistPDA };
    } finally {
      setIsLoading(false);
    }
  }, [program, provider, fetchPlaylists]);

  // Add a track to a playlist; only pass PDAs (owner inferred in 0.31+)
  const addTrackToPlaylist = useCallback(async (playlistPDA: PublicKey, trackPDA: PublicKey) => {
    if (!program || !provider) throw new Error('Program not initialized');

    setIsLoading(true);
    try {
      await program.methods
        .addTrackToPlaylist()
        .accounts({
          playlist: playlistPDA,
          track: trackPDA,
          // owner usually inferred via has_one in your IDL
        })
        .rpc();

      await fetchPlaylists();
    } finally {
      setIsLoading(false);
    }
  }, [program, provider, fetchPlaylists]);

  // Remove a track; only pass PDAs (owner inferred)
  const removeTrackFromPlaylist = useCallback(async (playlistPDA: PublicKey, trackPDA: PublicKey) => {
    if (!program || !provider) throw new Error('Program not initialized');

    setIsLoading(true);
    try {
      await program.methods
        .removeTrackFromPlaylist()
        .accounts({
          playlist: playlistPDA,
          track: trackPDA,
          // owner inferred
        })
        .rpc();

      await fetchPlaylists();
    } finally {
      setIsLoading(false);
    }
  }, [program, provider, fetchPlaylists]);

  return {
    // On-chain data in memory
    tracks,
    playlists,

    // Actions
    initializeUser,
    uploadTrack,
    createPlaylist,
    addTrackToPlaylist,
    removeTrackFromPlaylist,

    // State
    isLoading,
    program,   // Program<MusicPlayer> | null
    provider,  // AnchorProvider | null

    // Fetchers (for manual refresh)
    fetchTracks,
    fetchPlaylists,
  };
};
